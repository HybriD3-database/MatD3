\documentclass{article}

\usepackage{verbatim}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{color}
\lstset{frame=tb,
  language=Python,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{green},
  stringstyle=\color{red},
}
\usepackage{hyperref}
\hypersetup{colorlinks,%
citecolor=blue,%
filecolor=blue,%
linkcolor=blue,%
urlcolor=blue,%
pdftex}

\title{HybriD$^3$ database}

\begin{document}

\maketitle

\section{Access and setup}

The repository of the HybriD$^3$ database is hosted at Duke's GitLab website under Xiaochen Du's account. First, make sure you have access to the GitLab by logging in to
\lstset{language=Bash}
\begin{lstlisting}
  https://gitlab.oit.duke.edu
\end{lstlisting}
Then, one of the HybriD$^3$ team members will give you access to the project, which is located at
\begin{lstlisting}
  https://gitlab.oit.duke.edu/xd24/hybrid3-database
\end{lstlisting}
In order to have pull/push privileges, you must upload your RSA public key to Duke's GitLab. If you already have one, it is likely located at \verb+.ssh/id_rsa.pub+. If not, the RSA public/private key pair can be generated by issuing
\begin{lstlisting}
  ssh-keygen
\end{lstlisting}
It is sufficient to press enter at each query until the keys have been generated, although protecting the key with a password would be a good idea if it's hosted at a public server. Then, at Duke's GitLab website, go to your settings, find ``SSH keys'', and enter the public key. You can upload several keys if want to have pull/push access from more than one computer. You can now clone the Git repository with
\begin{lstlisting}
  git clone git@gitlab.oit.duke.edu:xd24/hybrid3-database.git
\end{lstlisting}

In order to ensure compatibility with the correct Python packages, it is important to do the development in a Python virtual environment. You can create the virtual environment with
\begin{lstlisting}
  python3 -m venv hybrid3env
\end{lstlisting}
and activate the environment with
\begin{lstlisting}
  source hybrid3env/bin/activate
\end{lstlisting}
You'll notice that the shell's prompt has changed to remind you that you are in a virtual environment. Any packages installed with Python's \verb+pip+ command are now part of the current project only. The correct versions of the packages that are required for developing the HybriD$^3$ database are listed in requirements.txt. Install them all by issuing
\begin{lstlisting}
  pip install -r requirements.txt
\end{lstlisting}
When you make changes to the requirements, such as upgrading a Python package, use
\begin{lstlisting}
  pip freeze > requirements.txt
\end{lstlisting}
to record the new list of requirements. Since this will overwrite the current requirements file, it is important to apply the old requirements first before making any changes.

\section{Development notes}

The most important configuration file for the project is \texttt{settings.py} located under \texttt{mainproject}. It is set up specifically for the server where HybriD$^3$ is currently hosted (\texttt{materials.hybrid3.duke.edu}) and needs to be modified for your local development. Since that file is under version control and meant for production use only, it is better to create a separate file for any local development and not modify the main settings file.

You may start, e.g., by creating \verb+mainproject/settings_local.py+ with the following contents:
\lstset{language=Python}
\begin{lstlisting}
from .settings import *
DEBUG = True
SECRET_KEY = 'GF#QhIU%}4;auyFdIr]6>$_~|=."9qB%[Oj;.<^$IkNAgp0E{d'
ALLOWED_HOSTS += ['localhost']
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
\end{lstlisting}
Most settings are imported from the main settings file unmodified and only things that you want to change are recorded in the local file. Note that this is a rare exception for using \verb+import *+, which is otherwise considered poor style and in violation with the PEP 8 guidelines. In order to start the development server, the environment variable \verb+DJANGO_SETTINGS_MODULE+ has to point to the location of the local settings file in the form of a Python module:
\lstset{language=Bash}
\begin{lstlisting}
  export DJANGO_SETTINGS_MODULE=mainproject.settings_local
\end{lstlisting}
Next start the server with
\begin{lstlisting}
  ./manage.py runserver
\end{lstlisting}
and open \verb+localhost:8000+ in your web browser. You can browse the site just like the public one, but you will notice that there are no materials in the database. This is because your local settings are pointing to an empty local SQLite database. One solution is to import the contents from the production server to the SQLite database, but it is better to use the same database type on both your own computer and the production server, which would be MariaDB. In order to switch to MariaDB, make the following change in the local settings file:
\lstset{language=Python}
\begin{lstlisting}
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'materials',
        'USER': 'user',
    }
}
\end{lstlisting}
Then perform the following steps:
\begin{itemize}
\item Install and start the MariaDB server on your computer. Create a database called ``materials'' for the user ``user'' (username can be anything).
\item Copy the database contents from the public server. First, log in to the server:
  \begin{lstlisting}
    ssh <user>@materials.hybrid3.duke.edu
  \end{lstlisting}
\item Fetch the entire database contents:
  \begin{lstlisting}
    mysqldump -u xd24 -p materials > dump.sql
  \end{lstlisting}
  You are asked for the database password, which you will find in the main settings file.
\item Copy the dump file to your computer
  \begin{lstlisting}
    scp <user>@materials.hybrid3.duke.edu:/home/<user>/dump.sql .
  \end{lstlisting}
\item Read the contents into the local database:
  \begin{lstlisting}
    mysql -u user -p materials < dump.sql
  \end{lstlisting}
  You may now delete the dump file on the server and on your computer.
\end{itemize}
You might need to adjust some of these steps to reflect your environment. Restart the development server and you should be able to browse all the materials currently present in the database.

If you want to go back to SQLite instead of MariaDB for development, you can migrate the database to SQLite using the following script:
\begin{verbatim}
  https://github.com/dumblob/mysql2sqlite
\end{verbatim}

Next, you should create a superuser:
\begin{lstlisting}
  python manage.py createsuperuser
\end{lstlisting}
In order to access the site with admin rights, add \verb+/admin+ to the url and login as the superuser. The admin page allows editing of all data stored in the database.

Typically, when making changes to the Python source code, the effects are immediately visible at the site. There is no need to even restart the server. New byte-code is automatically regenerated for modified files. However, if you are making changes to the models, it is necessary to \textit{migrate}. Migrations change the database structure, which depends on changes in the models. Unlike the byte-code, which regenerates itself on-the-fly as needed, any updates to the database need to be performed manually. If you change a model, things are unlikely to work until you migrate. To create the migration files, type
\begin{lstlisting}
  python manage.py makemigrations
\end{lstlisting}
This creates a file in the migrations directory that explains the changes that were made to the models, but it does not change anything about the database yet. The idea is to give you a chance to review the changes before applying them and, if necessary, make further modifications by hand. Next, run the migrations (this will write and apply the SQL statements for you) with
\begin{lstlisting}
  python manage.py migrate
\end{lstlisting}

Once you are satisfied with the changes on your local machine, the changes
need to be communicated to the real website. This is done using the Git version control system.

\subsection{Git}

Run
\begin{lstlisting}
  git status
\end{lstlisting}
to see which files have been modified. Run
\begin{lstlisting}
  git add
\end{lstlisting}
on each file you want to commit. By contrast, run
\begin{lstlisting}
  git rm
\end{lstlisting}
on each file you want to remove from version control (don't just remove them with \texttt{rm}).
In order to commit, issue
\begin{lstlisting}
  git commit
\end{lstlisting}
which prompts you with the commit message before the actual commit is run. The basics of how to write a commit message are well explained in this blog post: \url{https://chris.beams.io/posts/git-commit}. In short, start with a summary line consisting of no more than 50 characters, not followed by a period. Leave a blank line followed by further description if necessary. For small commits, just the summary line may be sufficient. Write the whole commit message in the imperative tense (i.e. ``Fix typo'' not ``Fixed typo''). Attention: never run \verb+git commit -a+ unless you are an experienced Git user! Issue
\begin{lstlisting}
  git push
\end{lstlisting}
to push the committed files to GitLab.

Git comes with tons of useful commands and being good at Git is a very useful skill to have. The basics of Git are nicely covered in the first three chapters of the Git book: \url{https://git-scm.com/book/en/v2}.

\section{Deploying on the server}

Log in to the production server,
\begin{lstlisting}
  ssh <user>@materials.hybrid3.duke.edu
\end{lstlisting}
go to the project's directory (\verb+/var/www/django+) and run
\begin{lstlisting}
  git pull
\end{lstlisting}
to update the files there. Next, migrate as you did on your own computer if necessary:
\begin{lstlisting}
  python manage.py makemigrations
  python manage.py migrate
\end{lstlisting}
Do not set the \verb+DJANGO_SETTINGS_MODULE+ environment variable as we are using the default production settings on the server.

Note: if you used SQLite on you own computer, but the production server uses MariaDB, it is possible for minor conflicts to arise between the two. If this happens, it is necessary to log into the MariaDB database on the server and make any fixes manually. This assumes good knowledge of relational databases and is the reason why it's better to use the same database for both development and production.

If you made any changes to the static files, you may need to run
\begin{lstlisting}
  python manage.py collectstatic
\end{lstlisting}
Finally, you may also need to run
\begin{lstlisting}
  sudo systemctl restart httpd
\end{lstlisting}
if some of the changes do not appear on the homepage. If you are unsure about things like migrations, static files, and restarting the server, it doesn't hurt to always run those commands.

A good place to get started and learn more about Django is the official Django tutorial, which starts here: \url{https://docs.djangoproject.com/en/2.1/intro/tutorial01}.

\end{document}

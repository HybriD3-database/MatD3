\documentclass{article}

\usepackage{verbatim}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{color}
\lstset{frame=tb,
  language=Python,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{green},
  stringstyle=\color{red},
}
\usepackage{hyperref}
\hypersetup{colorlinks,%
citecolor=blue,%
filecolor=blue,%
linkcolor=blue,%
urlcolor=blue,%
pdftex}
\usepackage{tcolorbox}

\title{Notes on the HybriD$^3$ database project}

\begin{document}

\maketitle

\tableofcontents

\section{Access and setup}

The repository of the HybriD$^3$ database is hosted by GitLab:
\lstset{language=Bash}
\begin{lstlisting}
  https://gitlab.com/raul_l/hybrid3-database
\end{lstlisting}
It's a public project, so anyone has clone access and the ability to create issues and merge requests. In order to contribute to the project directly, contact one of the HybriD$^3$ team members who will then grant you the developer status. For pull/push privileges you must upload your RSA public key to GitLab. If you already have one, it is likely located at \verb+.ssh/id_rsa.pub+. If not, the RSA public/private key pair can be generated by issuing
\begin{lstlisting}
  ssh-keygen
\end{lstlisting}
It is sufficient to press enter at each query until the keys have been generated. However, protecting the key with a password would be a good idea if you intend to keep it at a public server. Then, at the GitLab website, go to your settings, find ``SSH keys'', and enter the public key. You can upload several keys in order to have pull/push access from more than one computer. You can now clone the Git repository with
\begin{lstlisting}
  git clone git@gitlab.com:raul_l/hybrid3-database.git
\end{lstlisting}

In order to ensure compatibility with the correct Python packages, it is important to do the development in a Python virtual environment. You can create a virtual environment with
\begin{lstlisting}
  python3 -m venv venv
\end{lstlisting}
and activate the environment with
\begin{lstlisting}
  source venv/bin/activate
\end{lstlisting}
You'll notice that the shell's prompt has changed to remind you that you are in a virtual environment. Any packages installed with Python's \verb+pip+ command are now part of the current project only. The correct versions of the packages that are required for developing the HybriD$^3$ database are listed in requirements.txt. Install them all by issuing
\begin{lstlisting}
  pip install -r requirements.txt
\end{lstlisting}
When you make changes to the requirements, such as upgrading a Python package, use
\begin{lstlisting}
  pip freeze > requirements.txt
\end{lstlisting}
to record the new list of requirements. Since this will overwrite the current requirements file, it is important to apply the old requirements first before making any changes.

\section{Development notes}

The most important configuration file for the project is \texttt{settings.py} located under \texttt{mainproject}. This file would need to be reviewed and edited for each instance of the server. Most settings in it are already at reasonable (or correct) values and those that are most likely to be edited are stored in a separate file called \texttt{.env} in the root directory. This file is part the Python Decouple tool, which allows you to organize the project's settings without having to edit the version controlled main settings file and, most importantly, for keeping secrets out of version control. The \texttt{settings.py} and \texttt{.env} pair is in a way analogous to the \texttt{.gitignore} and \texttt{.git/info/exclude} pair. Each value in \texttt{settings.py} that is set using the \texttt{config} function should have a corresponding entry in \texttt{.env}, unless you are happy with the default value. An example \texttt{.env} might look something like this:
\begin{lstlisting}
SECRET_KEY=<key>
ALLOWED_HOSTS=.host1.com, .host2.com
EMAIL_HOST=smtp.sendgrid.net
EMAIL_HOST_USER=hybrid3
EMAIL_HOST_PASSWORD=<password>
\end{lstlisting}
where \texttt{<key>} and \texttt{<password>} would need to be replaced by their actual values.

When this is set up, start the server with
\begin{lstlisting}
  ./manage.py runserver
\end{lstlisting}
and open \verb+localhost:8000+ in your web browser. You can browse the site just like the public one, but you will notice that there are no materials in the database. This is because your local settings are pointing to an empty local SQLite database. To fix this, one solution is to import the database contents from the production server to the SQLite database. However, it is generally better to use the same database type in both development and production environments. This project uses MariaDB and it is recommended for you to set it up also on your own computer. In order to switch to MariaDB, make the following change in the local settings file:
\lstset{language=Python}
\begin{lstlisting}
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'materials',
        'USER': 'user',
    }
}
\end{lstlisting}
Then perform the following steps:
\begin{itemize}
\item Install and start the MariaDB server on your computer. Create a database called ``materials'' for the user ``user'' (you can change the latter).
\item Copy the database contents from the public server. First, log in to the server:
  \begin{lstlisting}
    ssh <user>@materials.hybrid3.duke.edu
  \end{lstlisting}
\item Fetch the entire database contents:
  \begin{lstlisting}
    mysqldump -u xd24 -p materials > dump.sql
  \end{lstlisting}
  You are asked for the database password, which you will find in the main settings file.
\item Copy the dump file to your computer
  \begin{lstlisting}
    scp <user>@materials.hybrid3.duke.edu:/home/<user>/dump.sql .
  \end{lstlisting}
\item Read the contents into the local database:
  \begin{lstlisting}
    mysql -u user -p materials < dump.sql
  \end{lstlisting}
  You may now delete the dump file on the server and on your computer.
\end{itemize}
You might need to adjust some of these steps to reflect your environment. Now restart the development server and you should be able to browse all the materials currently present in the database.

If you want to go back to SQLite instead of MariaDB for development, you can migrate the database to SQLite using the following script:
\begin{verbatim}
  https://github.com/dumblob/mysql2sqlite
\end{verbatim}

Next, you should create a superuser:
\begin{lstlisting}
  python manage.py createsuperuser
\end{lstlisting}
In order to access the site with admin rights, add \verb+/admin+ to the url and login as the superuser. The admin page allows editing of all data stored in the database.

Typically, when making changes to the Python source code, the effects are immediately visible at the site. There is no need to even restart the server. New byte-code is automatically regenerated for modified files. However, if you are making changes to the models, it is necessary to \textit{migrate}. Migrations change the database structure, which depends on changes in the models. Unlike the byte-code, which regenerates itself on-the-fly as needed, any updates to the database need to be performed manually. Thus, if you change a model, things are unlikely to work until you migrate. To create the migration files, type
\begin{lstlisting}
  python manage.py makemigrations
\end{lstlisting}
This creates a file in the migrations directory that explains the changes that were made to the models, but it does not change anything about the database yet. The idea is to give you a chance to review the changes before applying them and, if necessary, make further modifications by hand. Next, run the migrations (this will write and apply the SQL statements for you) with
\begin{lstlisting}
  python manage.py migrate
\end{lstlisting}

Once you are satisfied with the changes on your local machine, the changes
need to be synchronized with the real website. This is done using the Git version control system.

\subsection{Git}

Run
\begin{lstlisting}
  git status
\end{lstlisting}
to see which files have been modified. Run
\begin{lstlisting}
  git add
\end{lstlisting}
on each file you want to commit. Similarly, run
\begin{lstlisting}
  git rm
\end{lstlisting}
on each file you want to remove from version control (don't just remove them with \texttt{rm}).
In order to commit, issue
\begin{lstlisting}
  git commit
\end{lstlisting}
which prompts you with the commit message before the actual commit is performed. The basics of how to write a commit message are well explained in this blog post: \url{https://chris.beams.io/posts/git-commit}. In short, start with a summary line consisting of no more than 50 characters, not followed by a period. Leave a blank line followed by further description if necessary. For small commits, just the summary line may be sufficient. Write the whole commit message in the imperative tense (i.e. ``Fix typo'' not ``Fixed typo''). Attention: never run \verb+git commit -a+ unless you are an experienced Git user! Finally, issue
\begin{lstlisting}
  git push
\end{lstlisting}
to push the committed files to GitLab.

Git comes with tons of useful commands and being good at Git is generally a very useful skill to have. The basics of Git are nicely covered in the first three chapters of the Git book: \url{https://git-scm.com/book/en/v2}.

\section{Deploying on the server}

Log in to the production server,
\begin{lstlisting}
  ssh <user>@materials.hybrid3.duke.edu
\end{lstlisting}
go to the project's directory (\verb+/var/www/django+) and run
\begin{lstlisting}
  git pull
\end{lstlisting}
to update the files there. As the command name suggests, this pulls in everything that was pushed to the Gitlab server in the previous section. Next,  if necessary, migrate as you did on your own computer:
\begin{lstlisting}
  python manage.py migrate
\end{lstlisting}
Do not set the \verb+DJANGO_SETTINGS_MODULE+ environment variable as we are using the default production settings on the server.

Note: if you used SQLite on you own computer, but the production server uses MariaDB, it is possible for minor conflicts to arise between the two. If this happens, it is necessary to log into the MariaDB database on the server and make any fixes manually. This assumes good knowledge of relational databases and is the reason why it's better to use the same database for both development and production.

If you made any changes to the static files, you may need to run
\begin{lstlisting}
  python manage.py collectstatic --noinput
\end{lstlisting}
Finally, you may also need to run
\begin{lstlisting}
  sudo systemctl restart httpd
\end{lstlisting}
if some of the changes do not appear on the homepage. If you are unsure about some of these steps (migrations, static files, \ldots), just perform all of them --- it never hurts.

A good place to get started and learn more about Django is the official Django tutorial, which starts here: \url{https://docs.djangoproject.com/en/2.2/intro/tutorial01}.

\section{Adding new users}

When a new user is registered, all users with the superuser status receive an email. The new user cannot submit any new data until their status has been set to ``staff status'' by one of the superusers. Note that for security reasons, they should not have the superuser status without a good reason.

\section{Database structure}

This section provides an overview of the Django models used in this project. The presentation focuses on how the models are defined in the Python source code and not the actual SQL tables. For example, even though fields such as the primary key are not listed in the following, it is understood that these are automatically created for the SQL tables.

Most models inherit from a base models which records information of how each entry is created/updated. Since actual polymorphism is not supported in relational databases, Django explicitly copies these fields to any child models.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Base]
  \begin{itemize}
  \item \texttt{created} --- date the entry was created
  \item \texttt{updated} --- date the entry was last modified
  \item \texttt{created by} --- user that created the entry
  \item \texttt{updated by} --- user that updated the entry
  \end{itemize}
\end{tcolorbox}

All properties are stored in a table which contains the name of the property. \begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Property(Base)]
  \begin{itemize}
  \item \texttt{name} --- displayed name of the property
  \end{itemize}
\end{tcolorbox}

All units are stored in a table which contains the label field.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Unit(Base)]
  \begin{itemize}
  \item \texttt{label} --- ``nm'', ``cm$^2$ V$^{-1}$ s$^{-1}$'', \ldots
  \end{itemize}
\end{tcolorbox}

The table of systems includes, among other things, fields for the organic and inorganic components. These fields are mandatory, which ensures that only organic/inorganic perovskites can be entered into the database.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=System(Base)]
  \begin{itemize}
  \item \texttt{compound name} --- displayed name of the material
  \item \texttt{formula}
  \item \texttt{group} --- alternate names
  \item \texttt{organic} --- organic component
  \item \texttt{inorganic} --- inorganic component
  \item \texttt{description}
  \item \texttt{tags}
  \end{itemize}
\end{tcolorbox}

Authors and references are stored in the following tables.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Author(Base)]
  \begin{itemize}
  \item \texttt{first\_name}
  \item \texttt{last\_name}
  \item \texttt{institution}
  \item \texttt{reference} --- ManyToMany field that maps authors to references. This should be removed! Create a foreign key in \texttt{Reference} instead.
  \end{itemize}
\end{tcolorbox}
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Reference(Base)]
  \begin{itemize}
  \item \texttt{author\_count} --- number of authors
  \item \texttt{title}
  \item \texttt{journal}
  \item \texttt{vol}
  \item \texttt{pages\_start}
  \item \texttt{pages\_end}
  \item \texttt{year}
  \item \texttt{doi\_isbn}
  \end{itemize}
\end{tcolorbox}

All experimental and theoretical results are contained in data sets. A data set typically refers to a single value, table, or figure found in a reference. The quantity of primary interest is called the ``primary property''. For example, if the band gap depends on temperature, then the band gap and temperature would be the ``primary'' and ``secondary'' properties, respectively (think of these as y- and x-values in a plot).
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Dataset(Base)]
  \begin{itemize}
  \item \texttt{label} --- description of the data set
  \item \texttt{system} --- foreign key for System
  \item \texttt{primary\_property} --- foreign key for Property
  \item \texttt{primary\_unit} --- foreign key for Unit
  \item \texttt{secondary\_property} --- foreign key for Property
  \item \texttt{secondary\_unit} --- foreign key for Unit
  \item \texttt{reference} --- foreign key for Reference
  \item \texttt{visible} --- whether the data is visible on the website
  \item \texttt{plotted} --- whether data is plotted by default
  \item \texttt{experimental} --- whether the data is of experimental origin (theoretical if false)
  \item \texttt{dimensionality} --- 2D, 3D, \ldots
  \item \texttt{sample\_type} --- single crystal, powder, \ldots
  \item \texttt{crystal\_system} --- one of the seven crystal systems
  \item \texttt{extraction\_method} --- short explanation for how the data was obtained
  \item \texttt{representative} --- in case of multiple entries under the same property for a given material, whether this data set should be shown on the material's main page.
  \end{itemize}
\end{tcolorbox}

A data set consists of one or more data subsets. One is always present but there could be several if it is possible to logically group the data somehow. For instance, different curves in a figure would correspond to separate data subsets.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Subset(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- foreign key for Dataset
  \item \texttt{label} --- short description of this subset
  \end{itemize}
\end{tcolorbox}

A data subset consists of one or more data points. When describing a single value such as the band gap of a material with no additional dependencies, the whole data set would consist of one subset with only one data point with one numerical value.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Datapoint(Base)]
  \begin{itemize}
  \item \texttt{subset} --- foreign key for Subset
  \end{itemize}
\end{tcolorbox}

Finally, the actual data is stored in the \texttt{NumericalValue} table.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=NumericalValue(Base)]
  \begin{itemize}
  \item \texttt{datapoint} --- foreign key for Datapoint
  \item \texttt{qualifier} --- ``primary'', ``secondary''
  \item \texttt{type} --- ``accurate'', ``approximate'', ``lower/upper bound'', ``error''
  \item \texttt{value} --- floating point number
  \item \texttt{counter} --- counts the number of values attached to a given data point
  \end{itemize}
\end{tcolorbox}

Any errors (uncertainties) associated with a numerical value are stored in a separate table. In the code, the errors are then retrieved from the database by querying for numerical values with the \verb+select_related('error')+ function and checking if a value has an associated error (\verb+if hasattr(value, 'error')+).
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Error(Base)]
  \begin{itemize}
  \item \texttt{numerical\_value} --- foreign key for NumericalValue
  \item \texttt{value} --- floating point number
  \end{itemize}
\end{tcolorbox}

A separate table is used for values that are fixed across a data subset. For instance, if the curves of band gap vs dopant density were measured for different temperatures, then ``band gap'', ``dopant density'', and ``temperature'' would be ``primary'', ``secondary'', and ``fixed'', respectively. Unlike regular numerical values, the fixed values are far lesser in number so that we can attach the errors directly to the values without a performance penalty.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=NumericalValueFixed(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- foreign key for Dataset
  \item \texttt{subset} --- foreign key for Subset
  \item \texttt{physical\_property} --- foreign key for Property
  \item \texttt{unit} --- foreign key for Unit
  \item \texttt{value} --- floating point number
  \item \texttt{type} --- ``accurate'', ``approximate'', ``lower/upper bound'', ``error''
  \item \texttt{error} --- floating point number (optional)
  \end{itemize}
\end{tcolorbox}

If the dependence of the primary property is on something that cannot be stored as a floating point number, it is stored in the \texttt{Symbol} table. Example: the user enters band gap values a function of phase. The phases are then stored as strings in the following table.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Symbol(Base)]
  \begin{itemize}
  \item \texttt{datapoint} --- foreign key for Datapoint
  \item \texttt{value} --- a string
  \item \texttt{counter} --- counts the number of symbols attached to a given data point
  \end{itemize}
\end{tcolorbox}

In case of an experimental study, the details of the synthesis method and the experiment can be stored in the following tables.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=SynthesisMethod(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- foreign key for Datapoint
  \item \texttt{starting\_materials}
  \item \texttt{product}
  \item \texttt{description}
  \item \texttt{comments}
  \end{itemize}
\end{tcolorbox}

\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=ExperimentalDetails(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- foreign key for Datapoint
  \item \texttt{method}
  \item \texttt{description}
  \item \texttt{comments}
  \end{itemize}
\end{tcolorbox}

Similarly, in case of a theoretical study, the computational details are recorded in a separate table.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=ComputationalDetails(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- foreign key for Datapoint
  \item \texttt{code}
  \item \texttt{level\_of\_theory}
  \item \texttt{xc\_functional}
  \item \texttt{kgrid}
  \item \texttt{relativity\_level}
  \item \texttt{basis\_set\_definition}
  \item \texttt{numerical\_accuracy}
  \end{itemize}
\end{tcolorbox}

If a numerical value comes with an error or uncertainty (experimental or theoretical), then this value is stored separately.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Error(Base)]
  \begin{itemize}
  \item \texttt{numerical\_value} --- foreign key for NumericalValue
  \item \texttt{value} --- floating point number
  \end{itemize}
\end{tcolorbox}

User uploaded files are stored in \texttt{DatasetFile}.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=DatasetFile(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- foreign key for Dataset
  \item \texttt{dataset\_file} --- a file upload field
  \end{itemize}
\end{tcolorbox}

All user information is stored in the \texttt{UserProfile} table.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=UserProfile]
  \begin{itemize}
  \item \texttt{user}
  \item \texttt{description}
  \item \texttt{institution}
  \item \texttt{website}
  \item \texttt{phone}
  \item \texttt{image}
  \end{itemize}
\end{tcolorbox}

\section{Coding rules}

If you are unsure about any rule described in this section, see the source code for examples and clarification.

\subsection{Python}

\begin{itemize}
\item This project follows the PEP 8 style guide. Use a text editor that highlights parts of the code that do not conform to PEP 8 or use an external tool for that. One such tool is flake8 (\texttt{pip install flake8}). You can test your code by running \texttt{flake8 file.py}. Among other things, the maximum line length is 79 characters.
\end{itemize}

\subsection{HTML and Javascript}

\begin{itemize}
\item The maximum line length for Javascript is 80 characters.
\item See the Google style guide for instructions on formatting:\\ \url{https://google.github.io/styleguide/jsguide.html#formatting}.
\item The line length limit of HTML is harder to establish because of the highly nested nature of HTML. Although not as strict, try to keep the lines within 120 characters.
\item Use UNIX-style newlines (\n). Windows-style newlines (\r\n) are not allowed.
\end{itemize}

\subsection{Imports}

\begin{itemize}
\item Group imports as follows: standard system libraries, Django libraries, local libraries. Separate the groups by blank lines.
\item Within a group, sort the imports alphabetically. This also means that ``from \ldots'' should come before ``import \ldots''.
\item Do not import multiple things on one line. For example, ``import os, sys'' should be split into two imports.
\end{itemize}

\subsection{Template tags}

\begin{itemize}
\item Leave one space around the opening and closing symbols of a construct (e.g., \verb+{{+, \verb+%}+, \ldots).
\end{itemize}

\section{Other}

\begin{itemize}
\item Should it be necessary to clean the Django permissions table, run
  \begin{lstlisting}
    Permission.objects.all().delete()
  \end{lstlisting}
  This deletes all permissions. Once makemigrations and migrate are run, only the premissions for tables which are present are rebuilt.
\item In order to have an interactive shell, install iPython in the virtual environment (not just system wide).
\item The command for running tests with Coverage.py is
  \begin{lstlisting}
    coverage run manage.py test && coverage report -m
  \end{lstlisting}
  In order to save time and not rebuild the test database every time, use the \texttt{--keepdb} flag with test.
\end{itemize}

\end{document}

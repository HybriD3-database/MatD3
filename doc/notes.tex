\documentclass{article}

\usepackage{verbatim}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{color}
\lstset{frame=tb,
  language=Python,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{green},
  stringstyle=\color{red},
}
\usepackage{hyperref}
\hypersetup{colorlinks,%
citecolor=blue,%
filecolor=blue,%
linkcolor=blue,%
urlcolor=blue,%
pdftex}
\usepackage{tcolorbox}

\title{Notes on the HybriD$^3$ database project}

\begin{document}

\maketitle

\section{Access and setup}

The repository of the HybriD$^3$ database is hosted at Duke's GitLab website under Xiaochen Du's account. First, make sure you have access to GitLab by logging in to
\lstset{language=Bash}
\begin{lstlisting}
  https://gitlab.oit.duke.edu
\end{lstlisting}
Then, one of the HybriD$^3$ team members will give you access to the project, which is located at
\begin{lstlisting}
  https://gitlab.oit.duke.edu/xd24/hybrid3-database
\end{lstlisting}
In order to have pull/push privileges, you must upload your RSA public key to Duke's GitLab. If you already have one, it is likely located at \verb+.ssh/id_rsa.pub+. If not, the RSA public/private key pair can be generated by issuing
\begin{lstlisting}
  ssh-keygen
\end{lstlisting}
It is sufficient to press enter at each query until the keys have been generated, although protecting the key with a password would be a good idea if you intend to keep it at a public server. Then, at Duke's GitLab website, go to your settings, find ``SSH keys'', and enter the public key. You can upload several keys in order to have pull/push access from more than one computer. You can now clone the Git repository with
\begin{lstlisting}
  git clone git@gitlab.oit.duke.edu:xd24/hybrid3-database.git
\end{lstlisting}

In order to ensure compatibility with the correct Python packages, it is important to do the development in a Python virtual environment. You can create a virtual environment with
\begin{lstlisting}
  python3 -m venv hybrid3env
\end{lstlisting}
and activate the environment with
\begin{lstlisting}
  source hybrid3env/bin/activate
\end{lstlisting}
You'll notice that the shell's prompt has changed to remind you that you are in a virtual environment. Any packages installed with Python's \verb+pip+ command are now part of the current project only. The correct versions of the packages that are required for developing the HybriD$^3$ database are listed in requirements.txt. Install them all by issuing
\begin{lstlisting}
  pip install -r requirements.txt
\end{lstlisting}
When you make changes to the requirements, such as upgrading a Python package, use
\begin{lstlisting}
  pip freeze > requirements.txt
\end{lstlisting}
to record the new list of requirements. Since this will overwrite the current requirements file, it is important to apply the old requirements first before making any changes.

\section{Development notes}

The most important configuration file for the project is \texttt{settings.py} located under \texttt{mainproject}. It is set up specifically for the server where HybriD$^3$ is currently hosted (\texttt{materials.hybrid3.duke.edu}) and needs to be modified for your local development. Since that file is under version control and meant for production use only, it is better to create a separate file for any local development and not modify the main settings file.

You may start, e.g., by creating \verb+mainproject/settings_local.py+ with the following contents:
\lstset{language=Python}
\begin{lstlisting}
from .settings import *
DEBUG = True
SECRET_KEY = 'GF#QhIU%}4;auyFdIr]6>$_~|=."9qB%[Oj;.<^$IkNAgp0E{d'
ALLOWED_HOSTS += ['localhost']
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
\end{lstlisting}
Most settings are imported from the main settings file unmodified and only things that you want to change are recorded in the local file. Note that this is a rare exception for using \verb+import *+, which is otherwise considered poor style and in violation with the PEP 8 guidelines. In order to start the development server, the environment variable \verb+DJANGO_SETTINGS_MODULE+ has to point to the dotted path of the local settings file:
\lstset{language=Bash}
\begin{lstlisting}
  export DJANGO_SETTINGS_MODULE=mainproject.settings_local
\end{lstlisting}
When this is set up, start the server with
\begin{lstlisting}
  ./manage.py runserver
\end{lstlisting}
and open \verb+localhost:8000+ in your web browser. You can browse the site just like the public one, but you will notice that there are no materials in the database. This is because your local settings are pointing to an empty local SQLite database. To fix this, one solution is to import the database contents from the production server to the SQLite database. However, it is generally better to use the same database type in both development and production environments. This project uses MariaDB and it is recommended for you to set it up also on your own computer. In order to switch to MariaDB, make the following change in the local settings file:
\lstset{language=Python}
\begin{lstlisting}
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'materials',
        'USER': 'user',
    }
}
\end{lstlisting}
Then perform the following steps:
\begin{itemize}
\item Install and start the MariaDB server on your computer. Create a database called ``materials'' for the user ``user'' (you can change the latter).
\item Copy the database contents from the public server. First, log in to the server:
  \begin{lstlisting}
    ssh <user>@materials.hybrid3.duke.edu
  \end{lstlisting}
\item Fetch the entire database contents:
  \begin{lstlisting}
    mysqldump -u xd24 -p materials > dump.sql
  \end{lstlisting}
  You are asked for the database password, which you will find in the main settings file.
\item Copy the dump file to your computer
  \begin{lstlisting}
    scp <user>@materials.hybrid3.duke.edu:/home/<user>/dump.sql .
  \end{lstlisting}
\item Read the contents into the local database:
  \begin{lstlisting}
    mysql -u user -p materials < dump.sql
  \end{lstlisting}
  You may now delete the dump file on the server and on your computer.
\end{itemize}
You might need to adjust some of these steps to reflect your environment. Now restart the development server and you should be able to browse all the materials currently present in the database.

If you want to go back to SQLite instead of MariaDB for development, you can migrate the database to SQLite using the following script:
\begin{verbatim}
  https://github.com/dumblob/mysql2sqlite
\end{verbatim}

Next, you should create a superuser:
\begin{lstlisting}
  python manage.py createsuperuser
\end{lstlisting}
In order to access the site with admin rights, add \verb+/admin+ to the url and login as the superuser. The admin page allows editing of all data stored in the database.

Typically, when making changes to the Python source code, the effects are immediately visible at the site. There is no need to even restart the server. New byte-code is automatically regenerated for modified files. However, if you are making changes to the models, it is necessary to \textit{migrate}. Migrations change the database structure, which depends on changes in the models. Unlike the byte-code, which regenerates itself on-the-fly as needed, any updates to the database need to be performed manually. Thus, if you change a model, things are unlikely to work until you migrate. To create the migration files, type
\begin{lstlisting}
  python manage.py makemigrations
\end{lstlisting}
This creates a file in the migrations directory that explains the changes that were made to the models, but it does not change anything about the database yet. The idea is to give you a chance to review the changes before applying them and, if necessary, make further modifications by hand. Next, run the migrations (this will write and apply the SQL statements for you) with
\begin{lstlisting}
  python manage.py migrate
\end{lstlisting}

Once you are satisfied with the changes on your local machine, the changes
need to be synchronized with the real website. This is done using the Git version control system.

\subsection{Git}

Run
\begin{lstlisting}
  git status
\end{lstlisting}
to see which files have been modified. Run
\begin{lstlisting}
  git add
\end{lstlisting}
on each file you want to commit. Similarly, run
\begin{lstlisting}
  git rm
\end{lstlisting}
on each file you want to remove from version control (don't just remove them with \texttt{rm}).
In order to commit, issue
\begin{lstlisting}
  git commit
\end{lstlisting}
which prompts you with the commit message before the actual commit is performed. The basics of how to write a commit message are well explained in this blog post: \url{https://chris.beams.io/posts/git-commit}. In short, start with a summary line consisting of no more than 50 characters, not followed by a period. Leave a blank line followed by further description if necessary. For small commits, just the summary line may be sufficient. Write the whole commit message in the imperative tense (i.e. ``Fix typo'' not ``Fixed typo''). Attention: never run \verb+git commit -a+ unless you are an experienced Git user! Finally, issue
\begin{lstlisting}
  git push
\end{lstlisting}
to push the committed files to GitLab.

Git comes with tons of useful commands and being good at Git is generally a very useful skill to have. The basics of Git are nicely covered in the first three chapters of the Git book: \url{https://git-scm.com/book/en/v2}.

\section{Deploying on the server}

Log in to the production server,
\begin{lstlisting}
  ssh <user>@materials.hybrid3.duke.edu
\end{lstlisting}
go to the project's directory (\verb+/var/www/django+) and run
\begin{lstlisting}
  git pull
\end{lstlisting}
to update the files there. As the command name suggests, this pulls in everything that was pushed to the Gitlab server in the previous section. Next,  if necessary, migrate as you did on your own computer:
\begin{lstlisting}
  python manage.py migrate
\end{lstlisting}
Do not set the \verb+DJANGO_SETTINGS_MODULE+ environment variable as we are using the default production settings on the server.

Note: if you used SQLite on you own computer, but the production server uses MariaDB, it is possible for minor conflicts to arise between the two. If this happens, it is necessary to log into the MariaDB database on the server and make any fixes manually. This assumes good knowledge of relational databases and is the reason why it's better to use the same database for both development and production.

If you made any changes to the static files, you may need to run
\begin{lstlisting}
  python manage.py collectstatic
\end{lstlisting}
Finally, you may also need to run
\begin{lstlisting}
  sudo systemctl restart httpd
\end{lstlisting}
if some of the changes do not appear on the homepage. If you are unsure about some of these steps (migrations, static files, \ldots), just perform all of them --- it never hurts.

A good place to get started and learn more about Django is the official Django tutorial, which starts here: \url{https://docs.djangoproject.com/en/2.1/intro/tutorial01}.

\section{Database structure}

This section provides an overview of the Django models used in this project. The presentation focuses on how the models are defined in the Python source code and not the actual SQL tables. For example, even though fields such as the primary key are not listed in the following, it is understood that these are automatically created for the SQL tables.

Most tables inherit from a base table which records the history of how each entry is created/updated. Since direct polymorphism is not supported in relational databases, what Django does is to explicitly copy these fields to any child models.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Base]
  \begin{itemize}
  \item \texttt{created} --- date the entry was created
  \item \texttt{updated} --- date the entry was last modified
  \item \texttt{created by} --- user that created the entry
  \item \texttt{updated by} --- user that updated the entry
  \end{itemize}
\end{tcolorbox}

All properties are stored in a table which contains the name and dimension of each property. All units are stored in a separate table with similar fields. By requiring the dimension of a property/unit pair to match \textit{a)} makes it easier for users to enter new data (e.g., by selecting ``wavelength'' only compatible units are shown) and \textit{b)} it also serves as a consistency check.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Property(Base)]
  \begin{itemize}
  \item \texttt{name} --- displayed name of the property
  \item \texttt{dimensions} --- length for ``lattice parameter''; energy and inverse distance for ``phonon energies'' (e.g. eV or cm$^{-1}$)
  \end{itemize}
\end{tcolorbox}

\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Unit(Base)]
  \begin{itemize}
  \item \texttt{name} --- ``nm'', ``cm$^2$ V$^{-1}$ s$^{-1}$'', \ldots
  \item \texttt{dimension} --- dimension
  \end{itemize}
\end{tcolorbox}

The table of systems includes, among other things, fields for the organic and inorganic components. These fields are mandatory, which ensures that only organic/inorganic perovskites can be entered into the database.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=System(Base)]
  \begin{itemize}
  \item \texttt{compound name} --- displayed name of the material
  \item \texttt{formula}
  \item \texttt{group} --- alternate names
  \item \texttt{organic} --- organic component
  \item \texttt{inorganic} --- inorganic component
  \item \texttt{description}
  \item \texttt{tags}
  \end{itemize}
\end{tcolorbox}

Authors and publications are stored in the following tables.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Author(Base)]
  \begin{itemize}
  \item \texttt{first\_name}
  \item \texttt{last\_name}
  \item \texttt{institution}
  \item \texttt{publication} --- ManyToMany field that maps authors to publications. This should be removed! Create a foreign key in \texttt{Publication} instead.
  \end{itemize}
\end{tcolorbox}
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Publication(Base)]
  \begin{itemize}
  \item \texttt{author\_count} --- number of authors
  \item \texttt{title}
  \item \texttt{journal}
  \item \texttt{vol}
  \item \texttt{pages\_start}
  \item \texttt{pages\_end}
  \item \texttt{year}
  \item \texttt{doi\_isbn}
  \end{itemize}
\end{tcolorbox}


All experimental and theoretical results are contained in data sets. A data set typically refers to a single value, table, or figure found in a publication. Note that even though the property is given in the \texttt{NumericalValue} table, we also include it here for search purposes.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Dataset(Base)]
  \begin{itemize}
  \item \texttt{label} --- description of the data set
  \item \texttt{system} --- reference to the primary key of System
  \item \texttt{property} --- reference to the primary key of Property
  \item \texttt{reference} --- reference to the primary key of Publication
  \item \texttt{plotted} --- whether data is plotted by default
  \item \texttt{input\_files} --- location of input files
  \item \texttt{origin} --- ``experiment''/``calculation''
  \item \texttt{visible} --- whether the data is visible on the website
  \end{itemize}
\end{tcolorbox}

A data set consists of one or more data series. If the data set describes, for example, the dielectric function measured at different temperatures, then each curve corresponding to a specific temperature would be a series in the data set. In most cases, a data set consists of just one series.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Dataseries(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- reference to the primary key of Dataset
  \item \texttt{label} --- short description of this series
  \end{itemize}
\end{tcolorbox}

A data series consists of one or more data points. When describing a single value such as the band gap of a material with no additional dependencies, the whole data set would consist of one series with one data point with one numerical value.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=Datapoint(Base)]
  \begin{itemize}
  \item \texttt{dataseries} --- reference to the primary key of Dataseries
  \end{itemize}
\end{tcolorbox}

Finally, the actual data is stored in the \texttt{NumericalValue} table. The quantity of primary interest has the ``primary'' qualifier. For example, if the band gap depends on temperature, then the band gap and temperature would have the ``primary'' and ``secondary'' qualifiers, respectively (think of these as y- and x-values in a plot). The property of the primary value must coincide with the data set property.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=NumericalValue(Base)]
  \begin{itemize}
  \item \texttt{datapoint} --- reference to the primary key of Datapoint
  \item \texttt{property} --- reference to the primary key of Property
  \item \texttt{unit} --- reference to the primary key of Unit
  \item \texttt{qualifier} --- ``primary'', ``secondary'', ``fixed''
  \item \texttt{value} --- floating point number
  \item \texttt{type} --- ``accurate'', ``approximate'', ``lower/upper bound'', ``error''
  \end{itemize}
\end{tcolorbox}

A separate table is used for values that are fixed for the whole data set or series. For instance, if the curves of band gap vs dopant density were measured for different temperatures, then ``band gap'', ``dopant density'', and ``temperature'' would be ``primary'', ``secondary'', and ``fixed'', respectively. Whether the value is fixed at the data set or series level depends on whether the \texttt{dataset} or \texttt{dataseries} field is non-null.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=NumericalValueFixed(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- reference to the primary key of Dataset
  \item \texttt{dataseries} --- reference to the primary key of Dataseries
  \item \texttt{property} --- reference to the primary key of Property
  \item \texttt{unit} --- reference to the primary key of Unit
  \item \texttt{value} --- floating point number
  \item \texttt{type} --- ``accurate'', ``approximate'', ``lower/upper bound'', ``error''
  \end{itemize}
\end{tcolorbox}

If the dependence of the primary property is on something that cannot be stored as a floating point number, it is stored in the \texttt{NonNumericalValue} table. Example: the user enters band gap values a function of phase. The phases are then stored as strings in the following table.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=NonNumericalValue(Base)]
  \begin{itemize}
  \item \texttt{datapoint} --- reference to the primary key of Datapoint
  \item \texttt{value} --- a string
  \end{itemize}
\end{tcolorbox}

In case of an experimental study, the details of the synthesis method can be recorded in the \texttt{SynthesisMethod} table, which links to a given data set.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=SynthesisMethod(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- reference to the primary key of Datapoint
  \item \texttt{method}
  \item \texttt{starting\_materials}
  \item \texttt{remarks}
  \item \texttt{product}
  \end{itemize}
\end{tcolorbox}

Similarly, in case of a theoretical study, the computational details are recorded in a separate table.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=ComputationalDetails(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- reference to the primary key of Datapoint
  \item \texttt{code}
  \item \texttt{theory\_level\_nonperturbative}
  \item \texttt{kgrid}
  \item \texttt{relativity\_level}
  \item \texttt{SO\_coupling} --- true/false
  \item \texttt{basis\_set}
  \item \texttt{postprocessing}
  \item \texttt{temperature}
  \item \texttt{pressure}
  \end{itemize}
\end{tcolorbox}

Band structures are treated differently from other physical properties. We specify only the reference to a data set and location of the data, which is currently stored in a text format on the hard drive.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=BandStructure(Base)]
  \begin{itemize}
  \item \texttt{dataset} --- reference to the primary key of Datapoint
  \item \texttt{folder\_location}
  \end{itemize}
\end{tcolorbox}

All user information is stored in the \texttt{UserProfile} table.
\begin{tcolorbox}[colback=green!5,colframe=green!40!black,title=UserProfile]
  \begin{itemize}
  \item \texttt{user}
  \item \texttt{description}
  \item \texttt{institution}
  \item \texttt{website}
  \item \texttt{phone}
  \item \texttt{image}
  \item \texttt{duke}
  \end{itemize}
\end{tcolorbox}

\section{Coding rules}

If you are unsure about any rule described in this section, see the source code for examples and clarification.

\subsection{Python}

\begin{itemize}
\item This project follows the PEP 8 style guide. Use a text editor that highlights parts of the code that do not conform to PEP 8 or use an external tool for that. One such tool is flake8 (\texttt{pip install flake8}). You can test your code by running \texttt{flake8 file.py}.
\end{itemize}

\subsection{Imports}

\begin{itemize}
\item Group imports as follows: standard system libraries, Django libraries, local libraries. Separate the groups by blank lines.
\item Within a group, sort the imports alphabetically. This also means that ``from \ldots'' should come before ``import \ldots''.
\item Do not import multiple things on one line. For example, ``import os, sys'' should be split into two imports.
\end{itemize}

\subsection{Template tags}

\begin{itemize}
\item Leave one space around the opening and closing symbols of a construct (e.g., \verb+{{+, \verb+%}+, \ldots).
\end{itemize}

\end{document}
